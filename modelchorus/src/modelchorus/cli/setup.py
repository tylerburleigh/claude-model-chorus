"""
Setup helper commands for ModelChorus.

Provides commands for /modelchorus-setup slash command.
"""

import json
import subprocess
import sys
from pathlib import Path
from typing import Optional, Dict, Any


def check_package_installed() -> Dict[str, Any]:
    """Check if modelchorus package is installed.

    Returns:
        Dict with installation status and details
    """
    try:
        result = subprocess.run(
            ['pip', 'show', 'modelchorus'],
            capture_output=True,
            text=True,
            check=False
        )

        if result.returncode == 0:
            # Package is installed
            lines = result.stdout.strip().split('\n')
            info = {}
            for line in lines:
                if ':' in line:
                    key, value = line.split(':', 1)
                    info[key.strip().lower()] = value.strip()

            return {
                "installed": True,
                "version": info.get('version', 'unknown'),
                "location": info.get('location', 'unknown'),
            }
        else:
            return {
                "installed": False,
                "message": "Package not found"
            }
    except Exception as e:
        return {
            "installed": False,
            "error": str(e)
        }


def install_package(dev_mode: bool = False) -> Dict[str, Any]:
    """Install modelchorus package.

    Args:
        dev_mode: If True, install in editable mode with -e flag

    Returns:
        Dict with installation result
    """
    try:
        if dev_mode:
            # Install in editable mode from current directory
            cmd = ['pip', 'install', '-e', '.']
        else:
            # Install from PyPI
            cmd = ['pip', 'install', 'modelchorus']

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False
        )

        if result.returncode == 0:
            return {
                "success": True,
                "message": f"Successfully installed modelchorus {'(dev mode)' if dev_mode else ''}",
                "output": result.stdout
            }
        else:
            return {
                "success": False,
                "message": "Installation failed",
                "error": result.stderr
            }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


def check_config_exists(project_root: Optional[Path] = None) -> Dict[str, Any]:
    """Check if .modelchorusrc config file exists.

    Args:
        project_root: Project root directory (defaults to cwd)

    Returns:
        Dict with config file status
    """
    if project_root is None:
        project_root = Path.cwd()

    config_files = [
        '.modelchorusrc',
        '.modelchorusrc.yaml',
        '.modelchorusrc.yml',
        '.modelchorusrc.json'
    ]

    for filename in config_files:
        config_path = project_root / filename
        if config_path.exists():
            return {
                "exists": True,
                "path": str(config_path),
                "filename": filename
            }

    return {
        "exists": False,
        "message": "No config file found"
    }


def create_config_file(
    project_root: Optional[Path] = None,
    default_provider: str = "claude",
    temperature: float = 0.7,
    max_tokens: Optional[int] = None,
    timeout: float = 120.0,
    workflows: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Create .modelchorusrc configuration file.

    Args:
        project_root: Project root directory (defaults to cwd)
        default_provider: Default AI provider
        temperature: Default temperature
        max_tokens: Default max tokens (optional)
        timeout: Default timeout in seconds
        workflows: Workflow-specific configurations (optional)

    Returns:
        Dict with creation result
    """
    if project_root is None:
        project_root = Path.cwd()

    config_path = project_root / '.modelchorusrc'

    # Check if file already exists
    if config_path.exists():
        return {
            "success": False,
            "message": f"Config file already exists: {config_path}",
            "path": str(config_path)
        }

    # Build config structure
    config = {
        "default_provider": default_provider,
        "generation": {
            "temperature": temperature,
            "timeout": timeout
        }
    }

    if max_tokens is not None:
        config["generation"]["max_tokens"] = max_tokens

    if workflows:
        config["workflows"] = workflows

    # Create YAML content
    yaml_content = f"""# ModelChorus Configuration
# This file was generated by /modelchorus-setup

# Default provider for all workflows
default_provider: {default_provider}

# Global generation parameters
generation:
  temperature: {temperature}
"""

    if max_tokens is not None:
        yaml_content += f"  max_tokens: {max_tokens}\n"

    yaml_content += f"  timeout: {timeout}\n"

    if workflows:
        yaml_content += "\n# Workflow-specific overrides\nworkflows:\n"
        for workflow_name, workflow_config in workflows.items():
            yaml_content += f"  {workflow_name}:\n"
            for key, value in workflow_config.items():
                if isinstance(value, list):
                    yaml_content += f"    {key}:\n"
                    for item in value:
                        yaml_content += f"      - {item}\n"
                else:
                    yaml_content += f"    {key}: {value}\n"

    try:
        with open(config_path, 'w') as f:
            f.write(yaml_content)

        return {
            "success": True,
            "message": f"Created config file: {config_path}",
            "path": str(config_path),
            "config": config
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


def create_tiered_config(
    project_root: Optional[Path] = None,
    tier: str = "quick",
    default_provider: str = "claude",
    temperature: float = 0.7,
    max_tokens: Optional[int] = None,
    timeout: float = 120.0,
    # Standard tier options
    consensus_providers: Optional[list] = None,
    consensus_strategy: str = "all_responses",
    research_depth: str = "thorough",
    research_citation_style: str = "academic",
    thinkdeep_thinking_mode: str = "medium",
    ideate_providers: Optional[list] = None,
    # Advanced tier options
    system_prompt: Optional[str] = None,
    workflow_overrides: Optional[Dict[str, Dict[str, Any]]] = None
) -> Dict[str, Any]:
    """Create tiered .modelchorusrc configuration file.

    Args:
        project_root: Project root directory (defaults to cwd)
        tier: Configuration tier (quick, standard, advanced)
        default_provider: Default AI provider
        temperature: Default temperature
        max_tokens: Default max tokens (optional)
        timeout: Default timeout in seconds
        consensus_providers: Providers for consensus workflow (standard+)
        consensus_strategy: Strategy for consensus workflow (standard+)
        research_depth: Research depth setting (standard+)
        research_citation_style: Citation style for research (standard+)
        thinkdeep_thinking_mode: Thinking mode for thinkdeep (standard+)
        ideate_providers: Providers for ideate workflow (standard+)
        system_prompt: Global system prompt (advanced)
        workflow_overrides: Additional workflow overrides (advanced)

    Returns:
        Dict with creation result
    """
    if project_root is None:
        project_root = Path.cwd()

    config_path = project_root / '.modelchorusrc'

    # Check if file already exists
    if config_path.exists():
        return {
            "success": False,
            "message": f"Config file already exists: {config_path}",
            "path": str(config_path)
        }

    # Build workflows config based on tier
    workflows = {}

    if tier in ["standard", "advanced"]:
        # Add consensus workflow
        if consensus_providers:
            workflows["consensus"] = {
                "providers": consensus_providers,
                "strategy": consensus_strategy
            }

        # Add research workflow
        workflows["research"] = {
            "citation_style": research_citation_style,
            "depth": research_depth
        }
        if consensus_providers:
            workflows["research"]["providers"] = consensus_providers

        # Add thinkdeep workflow
        workflows["thinkdeep"] = {
            "thinking_mode": thinkdeep_thinking_mode
        }

        # Add ideate workflow
        if ideate_providers:
            workflows["ideate"] = {
                "providers": ideate_providers
            }

    if tier == "advanced" and workflow_overrides:
        # Merge in additional workflow overrides
        for workflow_name, config in workflow_overrides.items():
            if workflow_name in workflows:
                workflows[workflow_name].update(config)
            else:
                workflows[workflow_name] = config

    # Use the existing create_config_file function with workflows
    return create_config_file(
        project_root=project_root,
        default_provider=default_provider,
        temperature=temperature,
        max_tokens=max_tokens,
        timeout=timeout,
        workflows=workflows if workflows else None
    )


def validate_config(project_root: Optional[Path] = None) -> Dict[str, Any]:
    """Validate .modelchorusrc configuration file.

    Args:
        project_root: Project root directory (defaults to cwd)

    Returns:
        Dict with validation result
    """
    if project_root is None:
        project_root = Path.cwd()

    # Import config loader
    try:
        from ..core.config import ConfigLoader
    except ImportError:
        return {
            "valid": False,
            "error": "Could not import ConfigLoader"
        }

    loader = ConfigLoader()
    config_path = loader.find_config_file(project_root)

    if not config_path:
        return {
            "valid": False,
            "message": "No config file found"
        }

    try:
        loader.load_config(config_path)
        return {
            "valid": True,
            "message": "Configuration is valid",
            "path": str(config_path)
        }
    except Exception as e:
        return {
            "valid": False,
            "error": str(e),
            "path": str(config_path)
        }


def check_permissions(project_root: Optional[Path] = None) -> Dict[str, Any]:
    """Check if Claude Code permissions are configured.

    Args:
        project_root: Project root directory (defaults to cwd)

    Returns:
        Dict with permissions status
    """
    if project_root is None:
        project_root = Path.cwd()

    settings_file = project_root / ".claude" / "settings.local.json"

    if not settings_file.exists():
        return {
            "configured": False,
            "message": "No .claude/settings.local.json file found"
        }

    try:
        with open(settings_file, 'r') as f:
            settings = json.load(f)

        permissions = settings.get('permissions', {}).get('allow', [])

        # Check for key modelchorus permissions
        has_modelchorus = any('modelchorus' in p for p in permissions)

        return {
            "configured": has_modelchorus,
            "permissions_count": len(permissions),
            "has_modelchorus_permissions": has_modelchorus
        }
    except Exception as e:
        return {
            "configured": False,
            "error": str(e)
        }


def add_to_gitignore(
    project_root: Optional[Path] = None
) -> Dict[str, Any]:
    """Add .modelchorusrc to project .gitignore.

    Args:
        project_root: Project root directory (defaults to cwd)

    Returns:
        Dict with result
    """
    if project_root is None:
        project_root = Path.cwd()

    gitignore_path = project_root / '.gitignore'

    # Entries to add
    entries_to_add = [
        '.modelchorusrc',
        '.modelchorusrc.yaml',
        '.modelchorusrc.yml',
        '.modelchorusrc.json'
    ]

    # Read existing gitignore or create new
    if gitignore_path.exists():
        try:
            with open(gitignore_path, 'r') as f:
                existing_content = f.read()
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to read .gitignore: {e}"
            }
    else:
        existing_content = ""

    # Check which entries are missing
    existing_lines = set(line.strip() for line in existing_content.split('\n'))
    entries_needed = [entry for entry in entries_to_add if entry not in existing_lines]

    if not entries_needed:
        return {
            "success": True,
            "message": "All entries already in .gitignore",
            "added_entries": []
        }

    # Add entries
    try:
        with open(gitignore_path, 'a') as f:
            # Add section header if file exists and doesn't end with newline
            if existing_content and not existing_content.endswith('\n'):
                f.write('\n')

            if existing_content:
                f.write('\n')

            f.write('# ModelChorus configuration\n')
            for entry in entries_needed:
                f.write(f'{entry}\n')

        return {
            "success": True,
            "message": f"Added {len(entries_needed)} entries to .gitignore",
            "added_entries": entries_needed,
            "path": str(gitignore_path)
        }
    except Exception as e:
        return {
            "success": False,
            "error": f"Failed to write .gitignore: {e}"
        }


def add_permissions(
    project_root: Optional[Path] = None
) -> Dict[str, Any]:
    """Add ModelChorus permissions to .claude/settings.local.json.

    Args:
        project_root: Project root directory (defaults to cwd)

    Returns:
        Dict with result
    """
    if project_root is None:
        project_root = Path.cwd()

    settings_file = project_root / ".claude" / "settings.local.json"

    # Define permissions to add
    permissions_to_add = [
        "Bash(modelchorus:*)",
    ]

    # Create .claude directory if needed
    settings_file.parent.mkdir(parents=True, exist_ok=True)

    # Load existing settings or create new
    if settings_file.exists():
        try:
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to read settings file: {e}"
            }
    else:
        settings = {
            "permissions": {
                "allow": []
            }
        }

    # Ensure permissions structure exists
    if 'permissions' not in settings:
        settings['permissions'] = {}
    if 'allow' not in settings['permissions']:
        settings['permissions']['allow'] = []

    # Add new permissions (avoiding duplicates)
    existing = set(settings['permissions']['allow'])
    added = []

    for perm in permissions_to_add:
        if perm not in existing:
            settings['permissions']['allow'].append(perm)
            added.append(perm)

    # Write updated settings
    try:
        with open(settings_file, 'w') as f:
            json.dump(settings, f, indent=2)
            f.write('\n')

        return {
            "success": True,
            "message": f"Added {len(added)} permissions",
            "added_permissions": added,
            "path": str(settings_file)
        }
    except Exception as e:
        return {
            "success": False,
            "error": f"Failed to write settings file: {e}"
        }


def main():
    """CLI entry point for setup commands."""
    import argparse

    parser = argparse.ArgumentParser(description="ModelChorus setup helper")
    subparsers = parser.add_subparsers(dest='command', help='Setup command')

    # check-install command
    subparsers.add_parser('check-install', help='Check if modelchorus is installed')

    # install command
    install_parser = subparsers.add_parser('install', help='Install modelchorus')
    install_parser.add_argument('--dev', action='store_true', help='Install in development mode')

    # check-config command
    config_parser = subparsers.add_parser('check-config', help='Check if config exists')
    config_parser.add_argument('--project', default=None, help='Project root directory')

    # create-config command
    create_parser = subparsers.add_parser('create-config', help='Create config file')
    create_parser.add_argument('--project', default=None, help='Project root directory')
    create_parser.add_argument('--provider', default='claude', help='Default provider')
    create_parser.add_argument('--temperature', type=float, default=0.7, help='Default temperature')
    create_parser.add_argument('--timeout', type=float, default=120.0, help='Default timeout')

    # create-tiered-config command
    tiered_parser = subparsers.add_parser('create-tiered-config', help='Create tiered config file')
    tiered_parser.add_argument('--project', default=None, help='Project root directory')
    tiered_parser.add_argument('--tier', default='quick', choices=['quick', 'standard', 'advanced'], help='Configuration tier')
    tiered_parser.add_argument('--provider', default='claude', help='Default provider')
    tiered_parser.add_argument('--temperature', type=float, default=0.7, help='Default temperature')
    tiered_parser.add_argument('--max-tokens', type=int, default=None, help='Default max tokens')
    tiered_parser.add_argument('--timeout', type=float, default=120.0, help='Default timeout')
    # Standard tier options
    tiered_parser.add_argument('--consensus-providers', nargs='+', help='Providers for consensus workflow')
    tiered_parser.add_argument('--consensus-strategy', default='all_responses', help='Consensus strategy')
    tiered_parser.add_argument('--research-depth', default='thorough', help='Research depth')
    tiered_parser.add_argument('--research-citation', default='academic', help='Research citation style')
    tiered_parser.add_argument('--thinkdeep-mode', default='medium', help='ThinkDeep thinking mode')
    tiered_parser.add_argument('--ideate-providers', nargs='+', help='Providers for ideate workflow')

    # validate-config command
    validate_parser = subparsers.add_parser('validate-config', help='Validate config file')
    validate_parser.add_argument('--project', default=None, help='Project root directory')

    # check-permissions command
    perm_check_parser = subparsers.add_parser('check-permissions', help='Check permissions')
    perm_check_parser.add_argument('--project', default=None, help='Project root directory')

    # add-permissions command
    perm_add_parser = subparsers.add_parser('add-permissions', help='Add permissions')
    perm_add_parser.add_argument('--project', default=None, help='Project root directory')

    # add-to-gitignore command
    gitignore_parser = subparsers.add_parser('add-to-gitignore', help='Add .modelchorusrc to .gitignore')
    gitignore_parser.add_argument('--project', default=None, help='Project root directory')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    project = Path(args.project) if hasattr(args, 'project') and args.project else None

    # Execute command
    if args.command == 'check-install':
        result = check_package_installed()
    elif args.command == 'install':
        result = install_package(dev_mode=args.dev)
    elif args.command == 'check-config':
        result = check_config_exists(project)
    elif args.command == 'create-config':
        result = create_config_file(
            project,
            default_provider=args.provider,
            temperature=args.temperature,
            timeout=args.timeout
        )
    elif args.command == 'create-tiered-config':
        result = create_tiered_config(
            project,
            tier=args.tier,
            default_provider=args.provider,
            temperature=args.temperature,
            max_tokens=args.max_tokens,
            timeout=args.timeout,
            consensus_providers=args.consensus_providers,
            consensus_strategy=args.consensus_strategy,
            research_depth=args.research_depth,
            research_citation_style=args.research_citation,
            thinkdeep_thinking_mode=args.thinkdeep_mode,
            ideate_providers=args.ideate_providers
        )
    elif args.command == 'validate-config':
        result = validate_config(project)
    elif args.command == 'check-permissions':
        result = check_permissions(project)
    elif args.command == 'add-permissions':
        result = add_permissions(project)
    elif args.command == 'add-to-gitignore':
        result = add_to_gitignore(project)
    else:
        print(json.dumps({"error": "Unknown command"}))
        sys.exit(1)

    # Output result as JSON
    print(json.dumps(result, indent=2))

    # Exit with appropriate code
    if 'success' in result:
        sys.exit(0 if result['success'] else 1)
    elif 'valid' in result:
        sys.exit(0 if result['valid'] else 1)
    elif 'installed' in result:
        sys.exit(0 if result['installed'] else 1)
    elif 'configured' in result:
        sys.exit(0 if result['configured'] else 1)
    else:
        sys.exit(0)


if __name__ == '__main__':
    main()
