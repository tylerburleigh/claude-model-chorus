Agent invocation successful.
Session ID: 67cbf888-1094-4b1f-a18b-e5455139c9b2
Provider: claude
Response:
I'll explain the key approaches for handling errors in async Python code.

## Basic Exception Handling

Use `try/except` blocks just like synchronous code:

```python
async def fetch_data():
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get('https://api.example.com/data') as response:
                return await response.json()
    except aiohttp.ClientError as e:
        print(f"Network error: {e}")
    except asyncio.TimeoutError:
        print("Request timed out")
    except Exception as e:
        print(f"Unexpected error: {e}")
```

## Handling Errors in Multiple Concurrent Tasks

### Using `asyncio.gather()` with `return_exceptions=True`

```python
async def main():
    results = await asyncio.gather(
        task1(),
        task2(),
        task3(),
        return_exceptions=True  # Returns exceptions instead of raising them
    )
    
    for result in results:
        if isinstance(result, Exception):
            print(f"Task failed: {result}")
        else:
            print(f"Task succeeded: {result}")
```

### Using `asyncio.TaskGroup()` (Python 3.11+)

```python
async def main():
    try:
        async with asyncio.TaskGroup() as tg:
            tg.create_task(task1())
            tg.create_task(task2())
            tg.create_task(task3())
    except* ValueError as eg:  # Exception groups with except*
        for exc in eg.exceptions:
            print(f"ValueError: {exc}")
    except* RuntimeError as eg:
        for exc in eg.exceptions:
            print(f"RuntimeError: {exc}")
```

## Handling Cancelled Tasks

```python
async def cancellable_task():
    try:
        await asyncio.sleep(10)
    except asyncio.CancelledError:
        print("Task was cancelled, cleaning up...")
        # Perform cleanup
        raise  # Re-raise to propagate cancellation
```

## Common Patterns

### Timeout handling:
```python
try:
    result = await asyncio.wait_for(some_coroutine(), timeout=5.0)
except asyncio.TimeoutError:
    print("Operation timed out")
```

### Creating safe wrappers:
```python
async def safe_execute(coro, default=None):
    try:
        return await coro
    except Exception as e:
        logger.error(f"Error in {coro.__name__}: {e}")
        return default
```

The key principle is that async exceptions work the same way as sync exceptions, but you need to be mindful of how exceptions propagate through concurrent tasks using `gather()`, `TaskGroup`, or individual task objects.
